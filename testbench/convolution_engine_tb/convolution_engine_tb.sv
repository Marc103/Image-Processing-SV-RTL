`timescale 1ns/10ps

/**
 * Tests the convolution engine
 *
 * DigitalImages are generated by a DigitalImageGenerator and are fed to both a DigitalImageDriver
 * and a ConvolutionModel
 *
 * The DigitalImageDriver is used to stimulate the DUT with the images produced by the
 * DigitalImageGenerator.
 *
 * The ConvolutionModel consumes images produced by the DigitalImageGenerator and produces convolved
 * images.
 *
 * The DUT Montior watches the DUT's output bus and converts the bus traffic to DigitalImages
 *
 * The Scoreboard compares results
 */

////////////////////////////////////////////////////////////////
// imports
import testbench_common_pkg::*;
import testbench_util_pkg::*;
import triggerable_queue_pkg::*;
import camera_simulation_pkg::*;
import pixel_data_interface_utils_pkg::*;
import golden_models_pkg::*;
`include "testbench_util_pkg.svh"


////////////////////////////////////////////////////////////////
// Includes
`include "conv_net.sv"
`include "afifo.v"
`include "async_fifo.v"
`include "sync_r2w.v"
`include "sync_w2r.v"
`include "wptr_full.v"
`include "fifomem.v"
`include "rptr_empty.v"

`timescale 1ns/1ps
module convolution_engine_tb;
    ////////////////////////////////////////////////////////////////
    // shared localparams
    localparam real PIXCLK_PERIOD = 5;

    localparam IMAGE_WIDTH = 100;
    localparam IMAGE_HEIGHT = 100;
    localparam KERNEL_WIDTH = 4;
    localparam KERNEL_HEIGHT = 4;

    // Fixed Point Arithmetic params
    localparam FP_M_IMAGE = 8;
    localparam FP_N_IMAGE = 0;
    localparam FP_S_IMAGE = 0;

    localparam FP_M_KERNEL = 0;
    localparam FP_N_KERNEL = 4;
    localparam FP_S_KERNEL = 0;

    localparam FP_M_IMAGE_OUT = 8;
    localparam FP_N_IMAGE_OUT = 0;
    localparam FP_S_IMAGE_OUT = 0;

    // Resultant bit widths
    localparam IMAGE_BIT_DEPTH = FP_M_IMAGE + FP_N_IMAGE + FP_S_IMAGE;
    localparam KERNEL_BIT_DEPTH = FP_M_KERNEL + FP_N_KERNEL + FP_S_KERNEL;
    localparam IMAGE_BIT_DEPTH_OUT = FP_M_IMAGE_OUT + FP_N_IMAGE_OUT + FP_S_IMAGE_OUT;

    // how many cycles do we have per pixel (should be <= (K_WIDTH * K_HEIGHT), otherwise it will break)
    localparam CLKS_PER_PIXEL = 11;

    // can't parallelize the work further
    localparam CLKS_MAX = (CLKS_PER_PIXEL > (KERNEL_HEIGHT*KERNEL_WIDTH)) ? (KERNEL_HEIGHT*KERNEL_WIDTH) : CLKS_PER_PIXEL;

    // constant extension value, kernel window values outside image
    localparam CONSTANT = 0;

    // Without compensating for fixed-point arithmetic, the correct value for this parameter is
    // IMAGE_BIT_DEPTH + log2(sum(kernel_values))
    // but this may be difficult to calculate at compile-time
    localparam CONVOLVED_IMAGE_BIT_DEPTH = 
                    IMAGE_BIT_DEPTH + KERNEL_BIT_DEPTH + $clog2(KERNEL_WIDTH * KERNEL_HEIGHT);

    // to work properly, must be >= CLKS_PER_PIXEL
    localparam PIXEL_CADENCE = 15;

    localparam INTER_IMAGE_TIME = (PIXEL_CADENCE * IMAGE_WIDTH * IMAGE_HEIGHT + 300) * PIXCLK_PERIOD;

    localparam N_IMAGES = 3;

    ////////////////////////////////////////////////////////////////
    // clock generation
    logic pixclk = 0;
    always begin #(PIXCLK_PERIOD/2); pixclk = ~pixclk; end

    ////////////////////////////////////////////////////////////////
    // common variables
    TriggerableQueue#(error_info_t) errors = new();

    ////////////////////////////////////////////////////////////////
    // interface instantiation and connection
    // we need some logic connected to interfaces so that vcd file captures them for gtkwave.
    pixel_data_interface #(
        .FP_M(FP_M_IMAGE),
        .FP_N(FP_N_IMAGE),
        .FP_S(FP_S_IMAGE)
    ) pixel_data_to_dut_iface(pixclk);

    pixel_data_interface #(
        .FP_M(FP_M_IMAGE_OUT),
        .FP_N(FP_N_IMAGE_OUT),
        .FP_S(FP_S_IMAGE_OUT)
    ) pixel_data_from_dut_iface(pixclk);


    ////////////////////////////////////////////////////////////////
    // DUT setup
    logic kernel_status_o;
    logic rst_n_i;
    logic [(KERNEL_BIT_DEPTH-1):0] kernel_coeffs_i [KERNEL_HEIGHT][KERNEL_WIDTH];
    logic w_pclk;
    logic w_dv;
    logic w_ispipefull;
    logic w_kernel_state;
    logic [$clog2(CLKS_PER_PIXEL):0] w_convolution_step;
    logic [(FP_M_IMAGE + FP_N_IMAGE + FP_S_IMAGE -1):0] w_kernel [KERNEL_HEIGHT][KERNEL_WIDTH];
    logic [15:0] w_col;
    logic [15:0] w_row;

    conv_net #(
        // Kernel FP params
        .FP_M_KERNEL(FP_M_KERNEL),
        .FP_N_KERNEL(FP_N_KERNEL),
        .FP_S_KERNEL(FP_S_KERNEL),

        .FP_M_IMAGE(FP_M_IMAGE),
        .FP_N_IMAGE(FP_N_IMAGE),
        .FP_S_IMAGE(FP_S_IMAGE),

        .WIDTH(IMAGE_WIDTH),
        .HEIGHT(IMAGE_HEIGHT),

        .K_WIDTH(KERNEL_WIDTH),
        .K_HEIGHT(KERNEL_HEIGHT),

        .CONSTANT(CONSTANT),
        .CLKS_PER_PIXEL(CLKS_PER_PIXEL)
    ) dut_0 (
        .in(pixel_data_to_dut_iface),

        // external wires
        .rst_n_i(rst_n_i),

        // feed to kernel modules
        .pclk_o(w_pclk),
        .dv_o(w_dv),
        .ispipefull_o(w_ispipefull),
        .kernel_state_o(w_kernel_state),
        .convolution_step_o(w_convolution_step),
        .kernel_o(w_kernel),
        .col_o(w_col),
        .row_o(w_row),

        .kernel_status_o(kernel_status_o)
    );

    kernel_convolution #(
        .FP_M_IMAGE(FP_M_IMAGE),
        .FP_N_IMAGE(FP_N_IMAGE),
        .FP_S_IMAGE(FP_S_IMAGE),
        
        .FP_M_KERNEL(FP_M_KERNEL),
        .FP_N_KERNEL(FP_N_KERNEL),
        .FP_S_KERNEL(FP_S_KERNEL), 

        .K_WIDTH(KERNEL_WIDTH),
        .K_HEIGHT(KERNEL_HEIGHT),

        .CLKS_PER_PIXEL(CLKS_MAX)
    ) kernel_convolution (
        .ispipefull_i(w_ispipefull),
        // kernel state
        .kernel_state_i(w_kernel_state),
        .convolution_step_i(w_convolution_step),
        // rest
        .kernel_i(w_kernel),
        .kernel_coeffs_i(kernel_coeffs_i),
        .col_i(w_col),
        .row_i(w_row),
        .pclk_i(w_pclk),
        .dv_i(w_dv),

        .out(pixel_data_from_dut_iface)
    );

    ////////////////////////////////////////////////////////////////
    // simulation environment
    // image generator, bus drivers, golden model, bus monitor, and scoreboard classes
    DigitalImageGenerator#(IMAGE_BIT_DEPTH) image_generator = new();
    initial begin
        image_generator.width = IMAGE_WIDTH; image_generator.height = IMAGE_HEIGHT;
        image_generator.period = INTER_IMAGE_TIME;
        image_generator.image_name = "../test_images/two_dogs_100_100.ppm";
    end

    DigitalImageDriver #(FP_M_IMAGE, FP_N_IMAGE, FP_S_IMAGE) 
        image_driver = new(image_generator.output_queue, pixel_data_to_dut_iface);

    initial begin image_driver.pixel_cadence = PIXEL_CADENCE; end

    ConvolutionModel#(
        // fp parms
        .FP_M_IMAGE(FP_M_IMAGE),
        .FP_N_IMAGE(FP_N_IMAGE),
        .FP_S_IMAGE(FP_S_IMAGE),
        
        .FP_M_KERNEL(FP_M_KERNEL),
        .FP_N_KERNEL(FP_N_KERNEL),
        .FP_S_KERNEL(FP_S_KERNEL),

        .FP_M_IMAGE_OUT(FP_M_IMAGE_OUT),
        .FP_N_IMAGE_OUT(FP_N_IMAGE_OUT),
        .FP_S_IMAGE_OUT(FP_S_IMAGE_OUT),

        .KERNEL_WIDTH(KERNEL_WIDTH),
        .KERNEL_HEIGHT(KERNEL_HEIGHT)
    )  golden = new(image_generator.output_queue, errors);

    PixelDataInterfaceMonitor #(FP_M_IMAGE_OUT, FP_N_IMAGE_OUT, FP_S_IMAGE_OUT)
        dut_monitor = new(pixel_data_from_dut_iface);

    // scoreboard
    DigitalImageScoreboard#(IMAGE_BIT_DEPTH_OUT) scoreboard = new(dut_monitor.output_queue,
                                                                       golden.output_queue,
                                                                       errors);
    initial scoreboard.finish_after = N_IMAGES;

    // watchdog that kills simulation when the DUT doesn't respond in a timely fashion.
    clocked_valid_interface dut_requester_interface(pixclk, pixel_data_to_dut_iface.valid);
    clocked_valid_interface dut_responder_interface(pixclk, pixel_data_from_dut_iface.valid);
    DataValidTimeoutWatchdog timeout_watchdog = new(dut_requester_interface,
                                                    dut_responder_interface,
                                                    errors);
    initial timeout_watchdog.timeout = (IMAGE_WIDTH * IMAGE_HEIGHT * CLKS_PER_PIXEL);

    // record images from image generator, from DUT and from model
    DigitalImageFileDumper#(IMAGE_BIT_DEPTH) gen_image_dumper = new(image_generator.output_queue);
    DigitalImageFileDumper#(IMAGE_BIT_DEPTH_OUT) dut_image_dumper = new(dut_monitor.output_queue);
    DigitalImageFileDumper#(IMAGE_BIT_DEPTH_OUT) golden_image_dumper = new(golden.output_queue);
    initial gen_image_dumper.basename = "gen_image";
    initial dut_image_dumper.basename = "dut_image";
    initial golden_image_dumper.basename = "mdl_image";

    // Initialize kernel for golden model and for DUT
    initial begin
        DigitalImage #(.BIT_DEPTH(KERNEL_BIT_DEPTH)) kernel = new(KERNEL_WIDTH, KERNEL_HEIGHT);

        for (int y = 0; y < kernel.height; y++) begin
            for (int x = 0; x < kernel.width; x++) begin
                kernel.image[y][x] = 4'b0001;
            end
        end

        golden.kernel = kernel;

        // TODO: initialze kernel inside DUT.
        kernel_coeffs_i = golden.kernel.image;

    end

    ////////////////////////////////////////////////////////////////
    // execution entry point
    initial begin
        // setup dumpfiles
        //$dumpfile("waves.vcd");
        //$dumpvars(0, convolution_engine_tb);

        $display();
        $display("Kernel Coefficients:");
        $display("%p", kernel_coeffs_i);
        $display();

        rst_n_i <= 1;
        repeat(5) @(posedge pixclk)
        rst_n_i <= 0;
        repeat(7) @(posedge pixclk)
        rst_n_i <= 1;

        // start all tasks for simulation components
        fork
            // tasks for main generation and testing pipeline
            image_generator.run();
            image_driver.run();
            golden.run();
            dut_monitor.run();
            scoreboard.run();

            // watchdog
            timeout_watchdog.run();

            // record images
            dut_image_dumper.run();
            golden_image_dumper.run();
            gen_image_dumper.run();
        join_none

        // wait for a while. Scoreboard should automatically stop us before this.
        #1000000000;

        begin
            error_info_t err
              = error_info_t'{ERROR_SEVERITY_ERROR, "convolution_engine_tb: scoreboard failed to stop", $time};
            errors.push(err);
        end
        print_errors_and_finish(errors);
    end
endmodule
